

* there is still an issue with (or a new issue with) writing to arduino memory, likely due to a NULL reference being derefenced as a struct, from the looks of the addresses
  It happens when running 'exec hello' on default boot

* syscalls to implement: wait, pipe, unlink, chdir, chmod, chown, lseek?, getuid/setuid, mount/umount, alarm, pause, time, kill


* get file deleting/unlinking working
* need a 'more' or hexdump type command for files
* send file is not working with the load script.  It causes a lockup of some kind because the buffer isn't read fast enough.  I think it might be related to task
  switching or a bug in the blocking logic
* what does the read() syscall docs say about returning without reading everything?  Perhaps passing a big buffer into read will help the serial input speed
* the resume checker isn't checking, but instead unblocking everything in the list to see if a second attempt fails
* get pipes working
* get exec/process arguments working
* add brk/sbrk/stack guard protection

* a page allocator is more needed, to replace the use of malloc for allocating the program space
* a slab allocator would maybe help, but I don't think it's as important at the moment



* there is an issue with load scripts that are an odd number of bytes, and the last byte wont be read/written because the loader operates on words

* there are writes being made to the arduino's program space, which seem to be happening after multitasking is started, but I'm not sure what's causing it.
  If it wasn't for the write protection in the arduino, it would trash the monitor program and require an arduino reset t work again

* pasting text into the serial terminal is causing characters to be lost on the 68k end, and it's not clear what the cause is.  The overrun bit is set.
  It could be miniterm doesn't properly handle RTS/CTS signals, or that they aren't configured correctly on the 68681 end.  I've got a workaround to
  send bytes of a file slowly so it doesn't overrun, but even reading exclusively from the input as fast as possible when run from rom doesn't make the
  problem disappear completely

* can you make the kernel relocatable again?

* rewrite the math functions to use fewer registers (this ain't a risc processor)
* you need some tests, but ideally it would use a simple emulator.  Maybe easy68k or something could be used

68k Single Board Computer:

	* in seems like AS in the interrupt ack is not necessary.  It can acknowledge the interrupt fine without it
	* a counter is not strictly needed for memory
	* add interrupt logic to schematic and pcb
	* you need a proper reset circuit that slowly turns it on through a cap?

	* if you have interrupts, and you connect at least one button to one of the IP change interrupts, then you could use the button for breaking into a debugger?
	* how can you modify the design to be better for debugging, possibly without an arduino.  Can you have step debugging through a hardware button, so that the bus
	  can be inspected?
	* can you have an debugger in the monitor software?  There are trap and breakpoint instructions in the processor for debugging, so if you define an interrupt handler
	  for those, you could have it enter a debugger, that possibly allows single stepping?  I'm not sure how to implement that

	* do I need optoisolators for the ftdi?  There is a blip where the arduino resets when the serial converter is connected

	* can you add a video/lcd expansion via the expansion connector?  Maybe you could get ends to directly connect it?  Would it be via parallel interface?
	  would you need a PIT 68230 to interface?  How complex are the interfaces of those graphic ones?
	* can you connect an esp01 as a wifi device?  I suppose you could connect it to the other serial port, even though it would be slow.  Is there another
	  way to get ethernet or wifi?

68k Arduino Shield:
	* need labels next to all pins
	* there's no way to reset the arduino with the shield on
	* there should be pins on the shield for anything not wired to the arduino directly, so that it can be plugged into despite ribbon cables being used
	* there should be a way on the arduino shield to enable, disable, or change the arduino's memory space



* it might be possible to do a 68030 single board computer, with 74LVC244/245 interfaces to an fpga chip, to provide the glue logic, but it would be a
  lot of surface mount chips, so you'd have to try a few smaller surface mount projects first
* make a surface mount/PLCC version of the 68k-SBC board to test SMT, since the design should work, and some of the memory chips are available as SMT

